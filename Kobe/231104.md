# Observables and Observers #1

- 옵져버블은 옵져버블 시퀀스 또는 시퀀스라고 부르기도 함.
    - Rx에서는 모두 옵져버블을 나타내는 용어임.

- 옵져버블은 이벤트를 전달함
    - 옵져버는 옵져버를 감시하고 있다가 전달되는 이벤트를 처리함.
        - 옵버저블을 감시하는 것을 구독한다고 표현함.
        - 그래서 옵저버를 구독자라고 부르기도 함.

- 옵저버블은 3가지 이벤트를 전달함.
    - 1. Next
        - 옵저버블에서 새롭게 발생한 이벤트는 Next 이벤트를 통해서 구독자로 전달됨.
            - 이벤트에 값이 포함되어 있다면 Next 이벤트와 함께 전달됨.
                - Rx에서는 이것을 Emission(우리말로 방출, 배출)라고 부름.
                    - 옵저버블의 라이프 사이클 동안 Next 이벤트가 하나도 전달되지 않는 경우가 있고, 하나 이상 전달되는 경우도 있음.
    - 2. Error.
        - 옵져버블에서 Error가 발생하면 전달되는 이벤트.
            - 옵저버블의 라이프 사이클에서 가장 마지막에 전달됨.
                - 이후 옵저버블이 종료되고 모든 리소스가 정리되기 때문에 다른 이벤트는 전달되지 않는다.
                    - Rx에서는 이것을 Notification이라고 부름.

    - 3. Completed.
        - 옵저버블이 정상적으로 종료되면 전달되는 이벤트.
            - 옵저버블의 라이프 사이클에서 가장 마지막에 전달됨.
                - 이후 옵저버블이 종료되고 모든 리소스가 정리되기 때문에 다른 이벤트는 전달되지 않는다.
                    - Rx에서는 이것을 Notification이라고 부름.

## 예시 코드 🧑‍💻

```swift
import RxSwift

// #1 Create 연산자를 통해서 직접 옵저버블을 직접 구현하는 방법.
Observable<Int>.create { (observer) -> Disposable in
    observer.on(.next(0))
    observer.onNext(1)
                        
    observer.onCompleted()

    return Disposables.create()
}

// #2 미리 정의된 규칙에 따라 이벤트를 전달하는 방법.
Obserbable.from([0, 1])
```
**코드 #1 설명**
- `create` 연산자는 옵저버블 타입 프로토콜에 선언되어 있는 타입 메서드임.
    - Rx에서는 이런 메서드를 "연산자"라고 부름.
        - 이 연산자는 하나의 클로저를 파라미터로 받음.
        - 이 클로저는 옵저버를 받아서 디스포저블을 리턴함.
            - 위 코드는 2개의 정수를 방출하는 코드이다.
                - 위 코드에서처럼 옵저버에서 `.on()` 메서드를 호출하고 `.next()` 이벤트에 숫자를 담아 전달하면 된다.
                    - 이렇게하면 구독자로 숫자가 저장된 `next` 이벤트가 전달됩니다.
                - 위 코드에서처럼 `.onNext()` 메서드를 사용하는 것도 가능함.
                - 위 코드에서처럼 `.onCompleted()` 메서드를 호출하면 `completed` 이벤트가 전달되고 옵저버블이 종료된다.
                    - 이후에 다른 이벤트를 전달할 수는 없다.

                - 위 코드에서 `Disposables.create()` 코드는 메모리 정리에 필요한 코드이다.

**코드 #2 설명**
- `from` 연산자는 파라미터로 전달한 배열에 있는 요소를 순서대로 방출하고 `completed` 이벤트를 전달하는 옵저버블을 생성합니다.
- 위 코드와 같이 단순히 순서대로 방출되는 옵저버블을 생성할 때는 `create` 연산자로 직접 구현하는 것 보다 `from`과 같은 다른 연산자들을 활용하는 것이 좋다.
    - 위 코드에서 보면 `Observable.from([0,1])`은 옵저버블이 생성된 상태일 뿐이다.
        - 다시 말해 정수가 방출되거나 이벤트가 전달된 것은 아니다.
        - 옵저버블은 이벤트가 어떤 순서로 전달되어야 하는지 정의할 뿐이다.
- ✅ **`#1에서 구현했던 클로저`가 실행되거나 `#2에서 from 연산자`로 만든 옵저버블에서 이벤트가 전달되는 시점은 바로 옵저버가 옵저버블을 구독하는 시점이다.**
    - 이 시점에 `next` 이벤트를 통해서 두 개의 정수가 순서대로 방출되고 이어서 `completed` 이벤트가 전달된다.
